<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
<title>Castle On The Hill â€” Minimal WebGL FPS</title>
<style>
  html, body { margin:0; height:100%; overflow:hidden; background:#0b0e12; color:#e8eef5; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; }
  #gl { width:100vw; height:100vh; display:block; touch-action:none; background:#0b0e12; }
  /* Start overlay */
  #startOverlay {
    position:fixed; inset:0; display:flex; align-items:center; justify-content:center; 
    background:radial-gradient(ellipse at center, rgba(10,14,18,0.9), rgba(10,14,18,0.98));
    z-index:10;
  }
  #startOverlay .card {
    background:#12161c; border:1px solid #283244; border-radius:14px; padding:18px 16px; width:min(90vw, 420px);
    box-shadow:0 4px 30px rgba(0,0,0,0.45); text-align:center;
  }
  button.primary { background:#3b82f6; color:#fff; border:none; border-radius:10px; padding:12px 16px; font-weight:600; cursor:pointer; width:100%; }
  button.primary:active { transform:translateY(1px); }
  .row { display:flex; gap:10px; margin-top:10px; justify-content:center; }
  .pill { font-size:12px; padding:6px 10px; border-radius:999px; background:#1b2330; border:1px solid #2b394d; }
  /* HUD */
  #crosshair { position:fixed; left:50%; top:50%; width:10px; height:10px; transform:translate(-50%,-50%); pointer-events:none; z-index:2; }
  #crosshair:after { content:""; position:absolute; left:4px; top:0; width:2px; height:10px; background:#e8eef5aa; }
  #crosshair:before { content:""; position:absolute; left:0; top:4px; width:10px; height:2px; background:#e8eef5aa; }
  #hint { position:fixed; left:50%; bottom:18px; transform:translateX(-50%); background:#0f1722cc; border:1px solid #273246; border-radius:10px; padding:8px 12px; font-size:13px; z-index:3; }
  #debug { position:fixed; left:8px; top:8px; font:12px/1.25 ui-monospace,Consolas,monospace; opacity:.75; }
  /* Dialogue / Interaction panel */
  #dialogue {
    position:fixed; left:50%; bottom:10%; transform:translateX(-50%);
    background:#111723; border:1px solid #283244; border-radius:12px; width:min(92vw, 560px); padding:12px; z-index:3; display:none;
  }
  #dialogue h3 { margin:.2rem 0 .5rem; font-size:16px; }
  #dialogue p { margin:.3rem 0 .7rem; color:#c9d4e6; }
  #dialogue .actions { display:flex; gap:8px; flex-wrap:wrap; }
  #dialogue button { background:#243148; color:#e8eef5; border:1px solid #2e3a52; border-radius:10px; padding:8px 10px; cursor:pointer; }
  #dialogue button.primary { background:#3b82f6; border-color:#2f65c6; }

  /* Mobile controls */
  .stick {
    position:fixed; bottom:18px; width:120px; height:120px; border-radius:50%;
    background:#0e1420b0; border:1px solid #2b394d; z-index:4; touch-action:none; display:none;
  }
  .knob {
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width:52px; height:52px; border-radius:50%; background:#1e293b; border:2px solid #3b82f6;
  }
  #leftStick { left:18px; }
  #rightStick { right:18px; }
  #interactBtn {
    position:fixed; right:22px; bottom:156px; background:#3b82f6; color:#fff; border:none; border-radius:999px; 
    padding:12px 16px; font-weight:700; z-index:4; display:none;
  }

  /* Tooltip for picked target */
  #targetName {
    position:fixed; left:50%; bottom:56px; transform:translateX(-50%);
    background:#101722cc; padding:6px 10px; border-radius:8px; font-size:12px; border:1px solid #283244; z-index:3; min-width:120px; text-align:center; display:none;
  }
</style>
</head>
<body>
<canvas id="gl"></canvas>

<div id="startOverlay">
  <div class="card">
    <h2 style="margin:.4rem 0 0.2rem;">Castle On The Hill</h2>
    <p style="opacity:.8; margin:.2rem 0 1rem;">Click to enter. Desktop uses mouse + WASD. Mobile gets virtual sticks. No installs. No excuses.</p>
    <button id="startBtn" class="primary">Start</button>
    <div class="row">
      <div class="pill">WASD = move</div>
      <div class="pill">Mouse/Right stick = look</div>
      <div class="pill">E / Tap = interact</div>
    </div>
  </div>
</div>

<div id="crosshair"></div>
<div id="hint" style="display:none;">Press <b>E</b> to interact</div>
<div id="targetName"></div>
<div id="debug"></div>

<div id="dialogue">
  <h3 id="dlgTitle">Name</h3>
  <p id="dlgText">...</p>
  <div class="actions" id="dlgActions"></div>
</div>

<!-- Mobile UI -->
<div id="leftStick" class="stick"><div class="knob"></div></div>
<div id="rightStick" class="stick"><div class="knob"></div></div>
<button id="interactBtn">Interact</button>

<!-- Game data (editable) -->
<script id="game-data" type="application/json">
{
  "world": {
    "castleCenter":[0,0,40],
    "hillRadius": 22,
    "hillHeight": 6
  },
  "npcs": [
    {
      "id":"blacksmith",
      "name":"Bruna the Blacksmith",
      "type":"townsfolk",
      "location":{"x":-22,"y":0,"z":-10},
      "lookAtPlayer": true,
      "dialogue": ["Need steel or stories? I've got one of those in stock."],
      "interactions": ["talk","trade"],
      "inventory": [{"item":"Iron Dagger","price":8}, {"item":"Repair Kit","price":5}]
    },
    {
      "id":"innkeeper",
      "name":"Merrit the Innkeep",
      "type":"townsfolk",
      "location":{"x":14,"y":0,"z":-16},
      "dialogue": ["Rooms are full. Tales are free."],
      "interactions": ["talk"]
    }
  ],
  "guards": [
    {
      "id":"g1",
      "name":"Castle Guard 1",
      "location":{"x":-6,"y":6,"z":34},
      "patrolRoute":[[-8,6,28],[-8,6,44],[8,6,44],[8,6,28]],
      "speed":1.2,
      "interactions":["talk","challenge"],
      "dialogue":["Password?" , "Wrong. Nice try."],
      "challenge":{"prompt":"Say the password.","pass":"dandelion"}
    },
    {
      "id":"g2",
      "name":"Castle Guard 2",
      "location":{"x":6,"y":6,"z":34},
      "patrolRoute":[[10,6,28],[10,6,44],[-10,6,44],[-10,6,28]],
      "speed":1.1,
      "interactions":["talk"],
      "dialogue":["Keep moving."]
    }
  ],
  "objects":[
    {
      "id":"gateDoor",
      "name":"Castle Gate",
      "type":"door",
      "position":[0,6,30.5],
      "size":[3,5,0.5],
      "hinge":"left",
      "openAngle":90,
      "locked": false
    },
    {
      "id":"townChest",
      "name":"Town Chest",
      "type":"chest",
      "position":[-18,0,-6],
      "size":[1.5,1,1],
      "locked": false,
      "loot":["Coin","Old Map"]
    },
    {
      "id":"notice",
      "name":"Town Notice",
      "type":"sign",
      "position":[8,0,-12],
      "size":[1.2,1.2,0.2],
      "text":"Market every third day. No sword fighting near the bakery."
    }
  ]
}
</script>

<script>
/* ============================
   Section A: Minimal math utils
   ============================ */
const TAU = Math.PI*2;
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
function vec3(x=0,y=0,z=0){return new Float32Array([x,y,z]);}
function add(a,b){return vec3(a[0]+b[0],a[1]+b[1],a[2]+b[2]);}
function sub(a,b){return vec3(a[0]-b[0],a[1]-b[1],a[2]-b[2]);}
function mul(a,s){return vec3(a[0]*s,a[1]*s,a[2]*s);}
function dot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];}
function len(a){return Math.hypot(a[0],a[1],a[2]);}
function norm(a){const l=len(a)||1; return vec3(a[0]/l,a[1]/l,a[2]/l);}
function cross(a,b){return vec3(a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]);}

function mat4(){return new Float32Array(16);}
function mIdent(){const m=mat4(); m[0]=m[5]=m[10]=m[15]=1; return m;}
function mMul(a,b){const o=mat4();
  for(let r=0;r<4;r++)for(let c=0;c<4;c++){
    o[c+4*r]=a[0+4*r]*b[c+0]+a[1+4*r]*b[c+4]+a[2+4*r]*b[c+8]+a[3+4*r]*b[c+12];
  } return o;
}
function mTrans(v){const m=mIdent(); m[12]=v[0]; m[13]=v[1]; m[14]=v[2]; return m;}
function mScale(v){const m=mIdent(); m[0]=v[0]; m[5]=v[1]; m[10]=v[2]; return m;}
function mRotY(a){const c=Math.cos(a), s=Math.sin(a); const m=mIdent(); m[0]=c; m[2]=s; m[8]=-s; m[10]=c; return m;}
function mRotX(a){const c=Math.cos(a), s=Math.sin(a); const m=mIdent(); m[5]=c; m[6]=-s; m[9]=s; m[10]=c; return m;}
function mPerspective(fov,aspect,near,far){
  const f=1/Math.tan(fov/2), nf=1/(near-far), m=mat4();
  m[0]=f/aspect; m[5]=f; m[10]=(far+near)*nf; m[11]=-1; m[14]=(2*far*near)*nf; return m;
}
function mLook(from, dir, upVec=vec3(0,1,0)){
  const f=norm(dir); const s=norm(cross(f, upVec)); const u=cross(s, f);
  const m=mIdent();
  m[0]=s[0]; m[4]=s[1]; m[8]=s[2];
  m[1]=u[0]; m[5]=u[1]; m[9]=u[2];
  m[2]=-f[0]; m[6]=-f[1]; m[10]=-f[2];
  m[12]=-dot(s, from); m[13]=-dot(u, from); m[14]=dot(f, from);
  return m;
}
/* Validation: math ops are pure and side-effect free; matrix shapes 4x4. Proceed. */

/* ===================================
   Section B: WebGL bootstrap + shader
   =================================== */
const canvas = document.getElementById('gl');
let gl = canvas.getContext('webgl', {antialias:true, alpha:false});
if(!gl){ alert('WebGL not supported. Try a newer browser.'); }

function resize(){ canvas.width=canvas.clientWidth; canvas.height=canvas.clientHeight; gl.viewport(0,0,gl.drawingBufferWidth, gl.drawingBufferHeight); }
addEventListener('resize', resize);

const VS=`
attribute vec3 aPos;
attribute vec3 aNormal;
uniform mat4 uMVP;
uniform mat4 uModel;
uniform vec3 uColor;
uniform vec3 uLightDir;
varying vec3 vColor;
void main(){
  vec3 n = normalize(mat3(uModel) * aNormal);
  float diff = max(dot(n, normalize(uLightDir)), 0.0);
  float amb = 0.25;
  float lit = amb + diff*0.8;
  vColor = uColor * lit;
  gl_Position = uMVP * vec4(aPos,1.0);
}`;
const FS=`
precision mediump float;
varying vec3 vColor;
void main(){ gl_FragColor = vec4(vColor, 1.0); }`;

function makeProgram(vsSrc, fsSrc){
  const vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, vsSrc); gl.compileShader(vs);
  if(!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(vs);
  const fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, fsSrc); gl.compileShader(fs);
  if(!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(fs);
  const p = gl.createProgram(); gl.attachShader(p,vs); gl.attachShader(p,fs); gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)) throw gl.getProgramInfoLog(p);
  return p;
}
const prog = makeProgram(VS,FS);
gl.useProgram(prog);
const loc = {
  aPos: gl.getAttribLocation(prog,'aPos'),
  aNormal: gl.getAttribLocation(prog,'aNormal'),
  uMVP: gl.getUniformLocation(prog,'uMVP'),
  uModel: gl.getUniformLocation(prog,'uModel'),
  uColor: gl.getUniformLocation(prog,'uColor'),
  uLightDir: gl.getUniformLocation(prog,'uLightDir')
};
/* Validation: shaders compile and link or throw; any console error means GPU/browser mismatch. Proceed if no exceptions. */

/* ==============================================
   Section C: Geometry builders (cube, plane, box)
   ============================================== */
function makeCube(){
  // Unit cube centered at origin, with face normals.
  const p = [
    // +X
    1,-1,-1, 1,1,-1, 1,1,1, 1,-1,1,
    // -X
    -1,-1,1, -1,1,1, -1,1,-1, -1,-1,-1,
    // +Y
    -1,1,-1, -1,1,1, 1,1,1, 1,1,-1,
    // -Y
    -1,-1,1, -1,-1,-1, 1,-1,-1, 1,-1,1,
    // +Z
    -1,-1,1, 1,-1,1, 1,1,1, -1,1,1,
    // -Z
    1,-1,-1, -1,-1,-1, -1,1,-1, 1,1,-1
  ];
  const n = [
    1,0,0, 1,0,0, 1,0,0, 1,0,0,
    -1,0,0,-1,0,0,-1,0,0,-1,0,0,
    0,1,0,0,1,0,0,1,0,0,1,0,
    0,-1,0,0,-1,0,0,-1,0,0,-1,0,
    0,0,1,0,0,1,0,0,1,0,0,1,
    0,0,-1,0,0,-1,0,0,-1,0,0,-1
  ];
  const idx = [];
  for(let f=0; f<6; f++){
    const off=f*4;
    idx.push(off,off+1,off+2, off,off+2,off+3);
  }
  return makeMesh(new Float32Array(p), new Float32Array(n), new Uint16Array(idx));
}
function makePlane(size=200){
  // big ground plane on XZ
  const hs = size/2;
  const p = new Float32Array([-hs,0,-hs,  -hs,0,hs,  hs,0,hs,  hs,0,-hs]);
  const n = new Float32Array([0,1,0, 0,1,0, 0,1,0, 0,1,0]);
  const idx = new Uint16Array([0,1,2, 0,2,3]);
  return makeMesh(p,n,idx);
}
function makeMesh(positions, normals, indices){
  const vao = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vao);
  const interleaved = new Float32Array(positions.length + normals.length);
  for(let i=0,j=0;i<positions.length/3;i++){
    interleaved[j++]=positions[i*3+0];
    interleaved[j++]=positions[i*3+1];
    interleaved[j++]=positions[i*3+2];
    interleaved[j++]=normals[i*3+0];
    interleaved[j++]=normals[i*3+1];
    interleaved[j++]=normals[i*3+2];
  }
  gl.bufferData(gl.ARRAY_BUFFER, interleaved, gl.STATIC_DRAW);
  const ibo = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
  return {vbo:vao, ibo:ibo, count:indices.length, stride:24};
}
/* Validation: cube and plane mesh creation binds buffers and counts indices; if you see undefined indices, my bad. Proceed. */

/* ==============================
   Section D: Scene composition
   ============================== */
const cube = makeCube();
const plane = makePlane(400);
const uLight = vec3(0.5, 1.0, 0.3);

function drawMesh(mesh, model, color, vp){
  gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vbo);
  gl.vertexAttribPointer(loc.aPos,3,gl.FLOAT,false,mesh.stride,0);
  gl.enableVertexAttribArray(loc.aPos);
  gl.vertexAttribPointer(loc.aNormal,3,gl.FLOAT,false,mesh.stride,12);
  gl.enableVertexAttribArray(loc.aNormal);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.ibo);
  const mvp = mMul(vp,