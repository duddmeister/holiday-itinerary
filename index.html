<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Hillcastle: A Tiny 3D Castle Adventure</title>
<style>
  html, body { margin:0; height:100%; background:#0b0d12; color:#e6e6e6; font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;}
  #game { position:fixed; inset:0; }
  canvas { width:100%; height:100%; display:block; touch-action:none; }
  /* HUD */
  .hud { position:fixed; inset:0; pointer-events:none; }
  .crosshair { position:absolute; left:50%; top:50%; width:12px; height:12px; transform:translate(-50%,-50%); border:2px solid #fff; border-radius:2px; opacity:.6; }
  .prompt { position:absolute; left:50%; bottom:12%; transform:translateX(-50%); background:rgba(0,0,0,.55); padding:8px 12px; border-radius:8px; font-size:14px; pointer-events:none; }
  .status { position:absolute; left:8px; top:8px; background:rgba(0,0,0,.45); padding:6px 8px; border-radius:8px; font-size:12px; line-height:1.3; pointer-events:none; max-width:45ch; }
  .btn { position:absolute; right:12px; bottom:12px; background:rgba(255,255,255,.12); border:1px solid rgba(255,255,255,.25); padding:10px 12px; border-radius:12px; font-weight:600; pointer-events:auto; }
  .btn:active { transform:scale(.98); }
  /* Dialogue */
  .dialogue { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.45); }
  .dlg-card { width:min(560px,92vw); background:#12151d; border:1px solid #263042; border-radius:16px; padding:14px; box-shadow:0 8px 24px rgba(0,0,0,.45); }
  .dlg-title { font-weight:700; margin-bottom:8px; }
  .dlg-body { font-size:14px; line-height:1.4; margin-bottom:10px; white-space:pre-wrap;}
  .dlg-actions { display:flex; flex-wrap:wrap; gap:8px; }
  .dlg-actions button { padding:8px 10px; border-radius:10px; border:1px solid #2f3a4f; background:#1a1f2a; color:#e6e6e6; cursor:pointer; }
  .dlg-actions button:active { transform:scale(.98); }
  /* Mobile controls */
  .touch-only { display:none; }
  @media (hover:none) and (pointer:coarse) {
    .touch-only { display:block; }
    .action-btn { position:absolute; right:14px; bottom:84px; width:70px; height:70px; border-radius:50%; background:rgba(255,255,255,.12); border:1px solid rgba(255,255,255,.25); display:grid; place-items:center; font-weight:700; pointer-events:auto; user-select:none; }
    .joystick { position:absolute; bottom:14px; width:140px; height:140px; border-radius:50%; border:1px dashed rgba(255,255,255,.25); background:rgba(255,255,255,.05); pointer-events:auto; }
    #joyL { left:14px; }
    #joyR { right:14px; }
    .knob { position:absolute; left:50%; top:50%; width:64px; height:64px; border-radius:50%; transform:translate(-50%,-50%); background:rgba(255,255,255,.15); border:1px solid rgba(255,255,255,.3); }
  }
  .fallback { position:fixed; inset:0; display:none; place-items:center; padding:24px; text-align:center; }
  .fallback .card { max-width:640px; background:#11151c; border:1px solid #2f3a4f; border-radius:16px; padding:18px; }
  a, button { color:#d7f3ff; }
</style>
</head>
<body>
<div id="game">
  <canvas id="glcanvas"></canvas>
  <div class="hud">
    <div class="crosshair"></div>
    <div id="prompt" class="prompt" style="display:none;"></div>
    <div id="status" class="status"></div>
    <button id="pauseBtn" class="btn">Pause</button>
    <div id="mobileUI" class="touch-only">
      <div id="joyL" class="joystick"><div class="knob"></div></div>
      <div id="joyR" class="joystick"><div class="knob"></div></div>
      <div id="actBtn" class="action-btn">USE</div>
    </div>
  </div>
</div>
<div id="dlg" class="dialogue">
  <div class="dlg-card">
    <div class="dlg-title" id="dlgTitle">NPC</div>
    <div class="dlg-body" id="dlgBody">...</div>
    <div class="dlg-actions" id="dlgActions"></div>
  </div>
</div>
<div id="fallback" class="fallback"><div class="card">
  <h2>WebGL required</h2>
  <p>Your browser didn’t give us a WebGL context. Try a modern browser or enable hardware acceleration. Until then, imagine a majestic castle on a hill and your character tripping over virtual chickens.</p>
</div></div>

<script>
/* =========================
   Section 0: Game data (schema-driven)
   ========================= */
const GAME_DATA = {
  npcs: [
    { id:"blacksmith", name:"Blacksmith", type:"townsfolk",
      location:{x: -18, y:0, z: 28}, interactions:["talk","trade"],
      dialog: { greet:"Need tools? I’ve got steel that bites." ,
                options:[{label:"Trade", action:"trade"},
                         {label:"Any work?", action:"quest"}] } },
    { id:"merchant", name:"Merchant", type:"townsfolk",
      location:{x: 6, y:0, z: 22}, interactions:["talk","trade"],
      dialog:{ greet:"Coin talks. Mostly it says goodbye.",
               options:[{label:"Show goods", action:"trade"}] } },
    { id:"child", name:"Town Kid", type:"townsfolk",
      location:{x: 14, y:0, z: 18}, interactions:["talk"],
      dialog:{ greet:"The guards say the hill is haunted. They’re boring.",
               options:[{label:"Stay safe", action:"close"}] } }
  ],
  guards: [
    { id:"g1", name:"Castle Guard 1",
      patrolRoute:[[0,0,-10],[10,0,-10],[10,0,0],[0,0,0]],
      interactions:["talk","challenge"],
      dialog:{ greet:"Keep to the path. No funny business.",
               options:[{label:"Any trouble?", action:"close"}] } },
    { id:"g2", name:"Castle Guard 2",
      patrolRoute:[[-10,0,-4],[-6,0,-14],[2,0,-12],[ -4,0,-2 ]],
      interactions:["talk"],
      dialog:{ greet:"Move along.",
               options:[{label:"Fine.", action:"close"}] } }
  ],
  objects: [
    { id:"gate", kind:"door", name:"Castle Gate",
      location:{x:0,y:0,z:-6}, size:{w:2.2,h:3.2,d:0.2},
      hinge:"left", interactions:["use","examine"],
      examine:"A heavy timber gate reinforced with iron bands." },
    { id:"chest1", kind:"chest", name:"Town Chest",
      location:{x:-16,y:0,z:26}, interactions:["examine","use"],
      examine:"Locked. The blacksmith might have opinions." },
    { id:"sign1", kind:"sign", name:"Town Noticeboard",
      location:{x:8,y:0,z:20}, interactions:["examine"],
      examine:"Festival postponed due to mysterious honking at dawn." }
  ],
  settings: {
    hillHeight: 6,
    worldSize: 120,
    townRadius: 28,
    castleTopRadius: 12
  }
};
/* Validation: data present and minimally shaped. */
if (!Array.isArray(GAME_DATA.npcs) || !Array.isArray(GAME_DATA.guards)) console.error("GAME_DATA invalid");

/* =========================
   Section 1: Minimal math utils
   ========================= */
const TAU = Math.PI*2;
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function vec3(x=0,y=0,z=0){ return new Float32Array([x,y,z]); }
function v3set(v,x,y,z){ v[0]=x;v[1]=y;v[2]=z; return v; }
function v3add(a,b,out=a){ out[0]=a[0]+b[0]; out[1]=a[1]+b[1]; out[2]=a[2]+b[2]; return out;}
function v3sub(a,b,out=a){ out[0]=a[0]-b[0]; out[1]=a[1]-b[1]; out[2]=a[2]-b[2]; return out;}
function v3scale(a,s,out=a){ out[0]=a[0]*s; out[1]=a[1]*s; out[2]=a[2]*s; return out;}
function v3len(a){ return Math.hypot(a[0],a[1],a[2]); }
function v3norm(a,out=a){ let l=v3len(a)||1; out[0]=a[0]/l; out[1]=a[1]/l; out[2]=a[2]/l; return out;}
function v3dot(a,b){ return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }

function mat4(){ return new Float32Array(16); }
function m4ident(out=mat4()){
  out.set([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); return out;
}
function m4mul(a,b,out=mat4()){
  const r=out;
  for(let i=0;i<4;i++){
    for(let j=0;j<4;j++){
      r[i*4+j]=a[i*4+0]*b[0*4+j]+a[i*4+1]*b[1*4+j]+a[i*4+2]*b[2*4+j]+a[i*4+3]*b[3*4+j];
    }
  }
  return r;
}
function m4translate(tx,ty,tz,out=m4ident()){
  out[12]=tx; out[13]=ty; out[14]=tz; return out;
}
function m4rotateY(a,out=m4ident()){
  const c=Math.cos(a), s=Math.sin(a);
  out.set([c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]); return out;
}
function m4rotateX(a,out=m4ident()){
  const c=Math.cos(a), s=Math.sin(a);
  out.set([1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1]); return out;
}
function m4scale(sx,sy,sz,out=m4ident()){
  out.set([sx,0,0,0, 0,sy,0,0, 0,0,sz,0, 0,0,0,1]); return out;
}
function m4persp(fovy, aspect, near, far, out=mat4()){
  const f=1/Math.tan(fovy/2), nf=1/(near-far);
  out.set([f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,(2*far*near)*nf,0]);
  return out;
}

/* Validation: core math ops exist; console won’t scream on imports. */

/* =========================
   Section 2: WebGL boilerplate + shader
   ========================= */
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl', {antialias:true});
const fallback = document.getElementById('fallback');
if (!gl) { fallback.style.display='grid'; throw new Error('WebGL unavailable'); }

function resize() {
  const dpr = Math.min(window.devicePixelRatio||1, 2);
  const w = Math.floor(canvas.clientWidth * dpr);
  const h = Math.floor(canvas.clientHeight * dpr);
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w; canvas.height = h; gl.viewport(0,0,w,h);
  }
}
window.addEventListener('resize', resize);

const VS = `
attribute vec3 aPos;
attribute vec3 aNormal;
attribute vec3 aColor;
uniform mat4 uModel, uView, uProj;
varying vec3 vColor;
varying vec3 vNormal;
void main(){
  vec4 world = uModel * vec4(aPos,1.0);
  vNormal = mat3(uModel) * aNormal;
  vColor = aColor;
  gl_Position = uProj * uView * world;
}`;
const FS = `
precision mediump float;
varying vec3 vColor;
varying vec3 vNormal;
uniform vec3 uLightDir;
void main(){
  vec3 n = normalize(vNormal);
  float diff = max(dot(n, -normalize(uLightDir)), 0.15);
  vec3 c = vColor * (diff + 0.05);
  gl_FragColor = vec4(c, 1.0);
}`;
function compile(type, src){
  const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s));
  return s;
}
function program(vs,fs){
  const p = gl.createProgram();
  gl.attachShader(p, compile(gl.VERTEX_SHADER, vs));
  gl.attachShader(p, compile(gl.FRAGMENT_SHADER, fs));
  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p));
  return p;
}
const prog = program(VS,FS);
gl.useProgram(prog);
const loc = {
  aPos: gl.getAttribLocation(prog,'aPos'),
  aNormal: gl.getAttribLocation(prog,'aNormal'),
  aColor: gl.getAttribLocation(prog,'aColor'),
  uModel: gl.getUniformLocation(prog,'uModel'),
  uView: gl.getUniformLocation(prog,'uView'),
  uProj: gl.getUniformLocation(prog,'uProj'),
  uLightDir: gl.getUniformLocation(prog,'uLightDir')
};
gl.enable(gl.DEPTH_TEST);
gl.clearColor(0.47/4,0.58/4,0.81/4,1);
/* Validation: shader compiles or throws with readable error. */

/* =========================
   Section 3: Mesh builders
   ========================= */
function createMesh(positions, normals, colors, indices){
  const vao = gl.createBuffer();
  const nbo = gl.createBuffer();
  const cbo = gl.createBuffer();
  const ibo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vao);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, nbo);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER, cbo);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
  return { vao, nbo, cbo, ibo, count: indices.length };
}
function bindMesh(m){
  gl.bindBuffer(gl.ARRAY_BUFFER, m.vao);
  gl.vertexAttribPointer(loc.aPos,3,gl.FLOAT,false,0,0);
  gl.enableVertexAttribArray(loc.aPos);
  gl.bindBuffer(gl.ARRAY_BUFFER, m.nbo);
  gl.vertexAttribPointer(loc.aNormal,3,gl.FLOAT,false,0,0);
  gl.enableVertexAttribArray(loc.aNormal);
  gl.bindBuffer(gl.ARRAY_BUFFER, m.cbo);
  gl.vertexAttribPointer(loc.aColor,3,gl.FLOAT,false,0,0);
  gl.enableVertexAttribArray(loc.aColor);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, m.ibo);
}
function boxMesh(w=1,h=1,d=1, color=[.8,.8,.8]){
  const x=w/2,y=h/2,z=d/2;
  const P=[
    // front
    -x,-y, z,  x,-y, z,  x, y, z,  -x, y, z,
    // back
    -x,-y,-z, -x, y,-z,  x, y,-z,  x,-y,-z,
    // left
    -x,-y,-z, -x,-y, z, -x, y, z, -x, y,-z,
    // right
     x,-y,-z,  x, y,-z,  x, y, z,  x,-y, z,
    // top
    -x, y, z,  x, y, z,  x, y,-z, -x, y,-z,
    // bottom
    -x,-y, z, -x,-y,-z,  x,-y,-z,  x,-y, z
  ];
  const N=[
    0,0,1, 0,0,1, 0,0,1, 0,0,1,
    0,0,-1,0,0,-1,0,0,-1,0,0,-1,
    -1,0,0,-1,0,0,-1,0,0,-1,0,0,
    1,0,0,1,0,0,1,0,0,1,0,0,
    0,1,0,0,1,0,0,1,0,0,1,0,
    0,-1,0,0,-1,0,0,-1,0,0,-1,0
  ];
  let C=[]; for(let i=0;i<24;i++) C.push(color[0],color[1],color[2]);
  const I=[];
  for(let f=0;f<6;f++){ const o=f*4; I.push(o,o+1,o+2, o,o+2,o+3); }
  return createMesh(P,N,C,I);
}
function terrainMesh(size=120, div=64, hillHeight=6){
  const step = size/div;
  const half = size/2;
  const P=[], N=[], C=[], I=[];
  function height(x,z){
    const cx=0, cz=-8; // hill center near castle
    const dx=x-cx, dz=z-cz;
    const r2=(dx*dx+dz*dz);
    const hill = hillHeight*Math.exp(-r2/450);
    const ripples = Math.sin(x*0.15)*0.15 + Math.cos(z*0.2)*0.1;
    return hill + ripples* (1 - Math.min(1, r2/2000));
  }
  const H=[];
  for(let iz=0; iz<=div; iz++){
    for(let ix=0; ix<=div; ix++){
      const x = ix*step - half;
      const z = iz*step - half;
      const y = height(x,z);
      P.push(x,y,z);
      C.push(0.30, 0.42, 0.29); // grass
      H.push(y);
    }
  }
  // indices
  for(let iz=0; iz<div; iz++){
    for(let ix=0; ix<div; ix++){
      const i0 = iz*(div+1)+ix;
      const i1 = i0+1;
      const i2 = i0+(div+1);
      const i3 = i2+1;
      I.push(i0,i2,i1, i1,i2,i3);
    }
  }
  // normals via finite differences
  N.length = (div+1)*(div+1)*3;
  function idx(ix,iz){ return iz*(div+1)+ix; }
  for(let iz=0; iz<=div; iz++){
    for(let ix=0; ix<=div; ix++){
      const i = idx(ix,iz);
      const x = P[i*3], y = P[i*3+1], z = P[i*3+2];
      const iL = idx(Math.max(ix-1,0),iz), iR = idx(Math.min(ix+1,div),iz);
      const iD = idx(ix,Math.max(iz-1,0)), iU = idx(ix,Math.min(iz+1,div));
      const vx = [P[iR*3]-P[iL*3], P[iR*3+1]-P[iL*3+1], P[iR*3+2]-P[iL*3+2]];
      const vz = [P[iU*3]-P[iD*3], P[iU*3+1]-P[iD*3+1], P[iU*3+2]-P[iD*3+2]];
      const nx = vx[1]*vz[2]-vx[2]*vz[1];
      const ny = vx[2]*vz[0]-vx[0]*vz[2];
      const nz = vx[0]*vz[1]-vx[1]*vz[0];
      const l = Math.hypot(nx,ny,nz)||1;
      N[i*3]=nx/l; N[i*3+1]=ny/l; N[i*3+2]=nz/l;
    }
  }
  return { mesh:createMesh(P,N,C,I), heightFn:(x,z)=>{ // bilinear sample
      const fx = (x+half)/step; const fz = (z+half)/step;
      const ix = Math.floor(clamp(fx,0,div)); const iz = Math.floor(clamp(fz,0,div));
      const i = iz*(div+1)+ix;
      return H[i]||0;
  }};
}
/* Validation: meshes build once; if indexes wrong, WebGL will error loudly. */

/* =========================
   Section 4: Scene construction
   ========================= */
const scene = [];
const terrain = terrainMesh(GAME_DATA.settings.worldSize, 80, GAME_DATA.settings.hillHeight);
scene.push({ mesh: terrain.mesh, model: m4ident(), kind:'terrain' });

function addBoxEntity(x,y,z, sx,sy,sz, color, kind='static', id=null){
  const mesh = boxMesh(sx,sy,sz,color);
  const model = m4mul(m4translate(x,y,z), m4ident());
  scene.push({ mesh, model, x,y,z, sx,sy,sz, color, kind, id, rotY:0 });
  return scene[scene.length-1];
}
// Castle walls and towers on hilltop
(function buildCastle(){
  const radius = GAME_DATA.settings.castleTopRadius;
  const wallH=3, wallT=0.6;
  // Four walls
  addBoxEntity(0, terrain.heightFn(0,-6)+wallH/2, -6, radius*2, wallH, wallT, [0.55,0.54,0.52], 'wall');
  addBoxEntity(0, terrain.heightFn(0, 6)+wallH/2,  6, radius*2, wallH, wallT, [0.55,0.54,0.52], 'wall');
  addBoxEntity(-radius, terrain.heightFn(-radius,0)+wallH/2, 0, wallT, wallH, radius*2, [0.55,0.54,0.52], 'wall');
  addBoxEntity( radius, terrain.heightFn( radius,0)+wallH/2, 0, wallT, wallH, radius*2, [0.55,0.54,0.52], 'wall');
  // Towers
  const tw=2.4; const th=5;
  addBoxEntity(-radius, terrain.heightFn(-radius,-6)+th/2, -6, tw,th,tw,[0.48,0.48,0.50],'tower');
  addBoxEntity( radius, terrain.heightFn( radius,-6)+th/2, -6, tw,th,tw,[0.48,0.48,0.50],'tower');
  addBoxEntity(-radius, terrain.heightFn(-radius, 6)+th/2,  6, tw,th,tw,[0.48,0.48,0.50],'tower');
  addBoxEntity( radius, terrain.heightFn( radius, 6)+th/2,  6, tw,th,tw,[0.48,0.48,0.50],'tower');
  // Keep
  addBoxEntity(0, terrain.heightFn(0,-1)+4, -1, 5,8,5,[0.44,0.44,0.48],'keep');
})();

// Town huts
(function buildTown(){
  for(let i=0;i<16;i++){
    const ang = i/16 * TAU;
    const r = GAME_DATA.settings.townRadius + 6 + Math.random()*6;
    const x = Math.cos(ang) * r;
    const z = Math.sin(ang) * r + 16;
    const y = terrain.heightFn(x,z);
    const w=2+Math.random()*1.2, d=2+Math.random()*1.2, h=1.6+Math.random()*0.8;
    addBoxEntity(x, y + h/2, z, w,h,d, [0.62,0.49,0.36],'house');
  }
})();

/* Interactive objects: doors, chests, signs (animated via transforms) */
const interactives = [];
function addDoor(obj){
  const {x,y,z} = obj.location;
  const h = obj.size?.h||3, w=obj.size?.w||2, d=obj.size?.d||0.2;
  const baseY = terrain.heightFn(x,z);
  const ent = addBoxEntity(x, baseY + h/2, z, w,h,d, [0.36,0.24,0.16], 'door', obj.id);
  ent.isDoor = true; ent.open=0; ent.hinge = obj.hinge||'left'; ent.name = obj.name;
  interactives.push(ent);
}
function addSimpleObject(obj, color, kind){
  const {x,y,z} = obj.location;
  const by = terrain.heightFn(x,z);
  const ent = addBoxEntity(x, by+0.5, z, 1,1,1, color, kind, obj.id);
  ent.name = obj.name; ent.examine = obj.examine||"";
  interactives.push(ent);
}
for(const obj of GAME_DATA.objects){
  if (obj.kind==='door') addDoor(obj);
  else if (obj.kind==='chest') addSimpleObject(obj,[0.35,0.27,0.12],'chest');
  else if (obj.kind==='sign') addSimpleObject(obj,[0.45,0.42,0.28],'sign');
}

/* NPCs/Guards as upright billboards (we rotate Y to face camera) */
function addBillboardNPC(n, tint){
  const ent = { id:n.id, kind:n.type==='guard'?'guard':'npc', name:n.name,
    x:n.location.x, y:terrain.heightFn(n.location.x,n.location.z), z:n.location.z,
    rotY:0, interactions:n.interactions||[], dialog:n.dialog||{}, radius:0.8, tint };
  scene.push({ mesh: boxMesh(0.8,1.8,0.2,tint), model:m4ident(), x:ent.x, y:ent.y+0.9, z:ent.z, rotY:0, kind:ent.kind, id:ent.id, entityRef:ent });
  return ent;
}
const npcs = [];
for(const n of GAME_DATA.npcs){ npcs.push(addBillboardNPC(n,[0.75,0.85,0.95])); }
const guards = [];
for(const g of GAME_DATA.guards){
  const guard = addBillboardNPC({ ...g, type:"guard", location:{ x:g.patrolRoute[0][0], y:0, z:g.patrolRoute[0][2] } }, [0.85,0.75,0.55]);
  guard.patrolRoute = g.patrolRoute.map(p=>({x:p[0],y:p[1],z:p[2]}));
  guard.interactions = g.interactions||["talk"];
  guard.dialog = g.dialog||{};
  guard.patrolIndex=0; guard.patrolT=0; guard.speed=1.6;
  guards.push(guard);
}

/* Validation: scene arrays populated; at least one terrain, some boxes, some NPCs. */

/* =========================
   Section 5: Camera, input, player
   ========================= */
const state = {
  camPos: vec3(0,1.6, 18),
  yaw: Math.PI, pitch: 0,
  forward: vec3(), right: vec3(1,0,0),
  keys: {}, pointerLocked:false, paused:false,
  mobile: matchMedia('(hover:none) and (pointer:coarse)').matches,
  moveVec:[0,0], lookVec:[0,0]
};
const view = mat4(), proj = mat4();

function updateVectors(){
  // forward vector from yaw/pitch (pitch clamped)
  const cp = Math.cos(state.pitch), sp = Math.sin(state.pitch);
  const cy = Math.cos(state.yaw), sy = Math.sin(state.yaw);
  v3set(state.forward, -sy*cp, sp, -cy*cp); // right-handed-ish
  v3set(state.right, cy, 0, -sy);
}
updateVectors();

function pointerLockSetup(){
  if (state.mobile) return;
  canvas.addEventListener('click', ()=>{ if (!state.pointerLocked) canvas.requestPointerLock(); });
  document.addEventListener('pointerlockchange', ()=>{ state.pointerLocked = (document.pointerLockElement===canvas); });
  document.addEventListener('mousemove', e=>{
    if (!state.pointerLocked || state.paused) return;
    const sens=0.0025;
    state.yaw -= e.movementX * sens;
    state.pitch -= e.movementY * sens;
    state.pitch = clamp(state.pitch, -1.2, 1.2);
    updateVectors();
  });
}
pointerLockSetup();

document.addEventListener('keydown', e=>{ state.keys[e.code]=true; if(e.code==='KeyE') tryInteract(); if(e.code==='Escape') togglePause(true); });
document.addEventListener('keyup', e=>{ state.keys[e.code]=false; });

/* Virtual joysticks */
const joyL = document.getElementById('joyL');
const joyR = document.getElementById('joyR');
const actBtn = document.getElementById('actBtn');
if (state.mobile){
  function makeJoystick(el, outVec, isLook){
    let touchId=null, base={x:0,y:0}, knob=el.querySelector('.knob');
    function pos(t){ const r = el.getBoundingClientRect(); return { x: t.clientX - (r.left + r.width/2), y: t.clientY - (r.top + r.height/2) }; }
    el.addEventListener('touchstart', e=>{
      if (touchId!=null) return;
      const t = e.changedTouches[0]; touchId=t.identifier; base=pos(t);
    });
    el.addEventListener('touchmove', e=>{
      for(const t of e.changedTouches){
        if (t.identifier!==touchId) continue;
        const p=pos(t); const max=55; const dx=clamp(p.x,-max,max), dy=clamp(p.y,-max,max);
        knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        outVec[0]=dx/max; outVec[1]=dy/max;
      }
    });
    function end(t){
      if (t.identifier!==touchId) return;
      touchId=null; outVec[0]=outVec[1]=0; knob.style.transform='translate(-50%,-50%)';
    }
    el.addEventListener('touchend', e=>{ for(const t of e.changedTouches) end(t); });
    el.addEventListener('touchcancel', e=>{ for(const t of e.changedTouches) end(t); });
  }
  makeJoystick(joyL, state.moveVec, false);
  makeJoystick(joyR, state.lookVec, true);
  actBtn.addEventListener('touchstart', ()=>tryInteract());
}

function movePlayer(dt){
  let vx=0,vz=0;
  if (!state.mobile){
    if (state.keys['KeyW']) vz -= 1;
    if (state.keys['KeyS']) vz += 1;
    if (state.keys['KeyA']) vx -= 1;
    if (state.keys['KeyD']) vx += 1;
  } else {
    // left joystick: x is strafe, y is forward/back
    vx = state.moveVec[0];
    vz = state.moveVec[1];
  }
  // apply look joystick on mobile
  if (state.mobile){
    const sens=0.03;
    state.yaw -= state.lookVec[0]*sens;
    state.pitch -= state.lookVec[1]*sens;
    state.pitch = clamp(state.pitch, -1.2, 1.2);
    updateVectors();
  }

  // movement in world space
  const speed = 3.2;
  const f = vec3(state.forward[0],0,state.forward[2]); v3norm(f,f);
  const r = vec3(state.right[0],0,state.right[2]); v3norm(r,r);
  let v = vec3();
  v3add(v3scale(r,vx), v3scale(f,-vz), v);
  const l = v3len(v); if (l>0) v3scale(v, speed*dt/l, v);
  v3add(state.camPos, v, state.camPos);

  // clamp to world and stick to heightmap
  const ws = GAME_DATA.settings.worldSize/2 - 2;
  state.camPos[0]=clamp(state.camPos[0], -ws, ws);
  state.camPos[2]=clamp(state.camPos[2], -ws, ws);
  const groundY = terrain.heightFn(state.camPos[0], state.camPos[2]);
  state.camPos[1] = groundY + 1.65;
}

/* Validation: WASD/touch affect camPos; yaw/pitch clamped to sane range. */

/* =========================
   Section 6: Interactions & UI
   ========================= */
const promptEl = document.getElementById('prompt');
const statusEl = document.getElementById('status');
const dlg = document.getElementById('dlg');
const dlgTitle = document.getElementById('dlgTitle');
const dlgBody = document.getElementById('dlgBody');
const dlgActions = document.getElementById('dlgActions');

function showPrompt(text){ promptEl.textContent=text; promptEl.style.display='block'; }
function hidePrompt(){ promptEl.style.display='none'; }

function openDialogue(title, text, options){
  dlgTitle.textContent = title;
  dlgBody.textContent = text || "";
  dlgActions.innerHTML='';
  (options||[{label:"Close",action:"close"}]).forEach(opt=>{
    const b=document.createElement('button'); b.textContent=opt.label;
    b.onclick=()=>{ if(opt.action==='close') closeDialogue(); else if(opt.action==='trade') dlgBody.textContent="Trading is a stub. You’re browsing without coin anyway."; else if(opt.action==='quest') dlgBody.textContent="Quest stub: fetch three feathers and a dramatic backstory."; };
    dlgActions.appendChild(b);
  });
  dlg.style.display='flex';
  togglePause(true,true);
}
function closeDialogue(){ dlg.style.display='none'; togglePause(false,true); }

document.getElementById('pauseBtn').addEventListener('click', ()=>{
  if (dlg.style.display==='flex') { closeDialogue(); return; }
  togglePause(!state.paused,true);
});

function togglePause(p, fromUI=false){
  state.paused = p;
  if (!state.mobile){
    if (!p && !fromUI && !state.pointerLocked) canvas.requestPointerLock();
  }
}

function playerForwardDotTo(target){
  const dir = vec3(target.x - state.camPos[0], 0, target.z - state.camPos[2]);
  v3norm(dir,dir);
  const f = vec3(state.forward[0],0,state.forward[2]); v3norm(f,f);
  return v3dot(dir,f);
}

function nearestInteractable(){
  let best=null; let bestD=2.5; const cosFOV = Math.cos(30*Math.PI/180);
  // NPCs and guards by their scene boxes
  for(const s of scene){
    if (s.kind==='terrain' || s.kind==='wall' || s.kind==='tower' || s.kind==='house' || s.kind==='keep') continue;
    const tx = s.x, tz = s.z, ty = s.y;
    const dx = tx - state.camPos[0], dz = tz - state.camPos[2];
    const d = Math.hypot(dx,dz);
    if (d<bestD){
      if (playerForwardDotTo({x:tx,z:tz}) >= cosFOV){
        best = s; bestD=d;
      }
    }
  }
  return best;
}

function tryInteract(){
  const s = nearestInteractable();
  if (!s) return;
  if (s.kind==='npc' || s.kind==='guard'){
    const e = s.entityRef;
    openDialogue(e.name, e.dialog?.greet||"...", e.dialog?.options||[{label:"Close",action:"close"}]);
  } else if (s.kind==='door' && s.isDoor){
    s.entityRef = s.entityRef||{};
    s.open = s.open>0.5?0:1;
  } else if (s.kind==='chest' || s.kind==='sign'){
    openDialogue(s.name, s.examine||"It exists.", [{label:"Close",action:"close"}]);
  }
}

/* Validation: prompt appears when aimed at entity within ~2.5m; E/use toggles doors or opens dialogue. */

/* =========================
   Section 7: Guard patrols
   ========================= */
function updateGuards(dt){
  for(const g of guards){
    const path = g.patrolRoute;
    if (!path || path.length<2) continue;
    const a = path[g.patrolIndex];
    const b = path[(g.patrolIndex+1)%path.length];
    const pos = vec3(g.x, g.y, g.z);
    const dir = vec3(b.x - a.x, 0, b.z - a.z);
    const dist = Math.max(0.001, Math.hypot(dir[0],dir[2]));
    const step = g.speed*dt;
    const toB = vec3(b.x - g.x, 0, b.z - g.z);
    if (Math.hypot(toB[0],toB[2]) <= step){
      g.x = b.x; g.z = b.z; g.y = terrain.heightFn(g.x,g.z);
      g.patrolIndex = (g.patrolIndex+1)%path.length;
    } else {
      v3norm(dir,dir);
      g.x += dir[0]*step; g.z += dir[2]*step; g.y = terrain.heightFn(g.x,g.z);
    }
    // Face movement direction for billboard
    g.rotY = Math.atan2(dir[0], dir[2]);
    // Update matching scene node (crude linear search to keep code small)
    for(const s of scene){ if (s.id===g.id || (s.entityRef && s.entityRef.id===g.id)){ s.x=g.x; s.z=g.z; s.y=g.y+0.9; s.rotY=g.rotY; } }
  }
}
/* Validation: guards loop over waypoints; if route bad, they’ll twitch at point 0. */

/* =========================
   Section 8: Render loop
   ========================= */
function drawNode(n){
  let M = m4ident();
  M = m4mul(m4translate(n.x||0, n.y||0, n.z||0), M);
  if (n.rotY) M = m4mul(m4rotateY(n.rotY), M);
  // Doors: rotate around hinge
  if (n.isDoor){
    const angle = n.open*1.3; // 0..~75deg
    const hingeLeft = n.hinge==='left';
    // move to hinge
    const sx=n.sx||1, sy=n.sy||1, sz=n.sz||1;
    const hx = (hingeLeft? -sx/2 : sx/2);
    M = m4mul(m4translate(hx, -(sy/2), 0), M);
    M = m4mul(m4rotateY( hingeLeft? angle : -angle ), M);
    M = m4mul(m4translate(-hx, sy/2, 0), M);
  }
  if (n.sx || n.sy || n.sz) M = m4mul(m4scale(n.sx||1,n.sy||1,n.sz||1), M);

  bindMesh(n.mesh);
  gl.uniformMatrix4fv(loc.uModel,false,M);
  gl.drawElements(gl.TRIANGLES, n.mesh.count, gl.UNSIGNED_SHORT, 0);
}

function render(time){
  if (!lastTime) lastTime = time;
  const dt = Math.min(0.05, (time - lastTime)/1000);
  lastTime = time;
  resize();
  if (!state.paused){
    movePlayer(dt);
    updateGuards(dt);
  }

  // camera matrices
  let V = m4ident();
  V = m4mul(m4rotateX(state.pitch), V);
  V = m4mul(m4rotateY(state.yaw), V);
  V = m4mul(m4translate(-state.camPos[0], -state.camPos[1], -state.camPos[2]), V);
  const aspect = canvas.width / Math.max(1, canvas.height);
  const P = m4persp(60*Math.PI/180, aspect, 0.05, 400);

  gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
  gl.uniformMatrix4fv(loc.uView,false,V);
  gl.uniformMatrix4fv(loc.uProj,false,P);
  gl.uniform3f(loc.uLightDir, 0.6, 1.0, 0.2);

  // update prompt
  const hit = nearestInteractable();
  if (hit) showPrompt(`Use [E] • ${hit.name||hit.kind}`); else hidePrompt();

  // sync billboard nodes to face camera horizontally
  for(const s of scene){
    if (s.kind==='npc' || s.kind==='guard'){
      const yaw = Math.atan2( state.camPos[0]-s.x, state.camPos[2]-s.z );
      s.rotY = yaw;
    }
  }

  // draw
  for(const n of scene) drawNode(n);

  // status text
  statusEl.textContent = `Pos: ${state.camPos[0].toFixed(1)}, ${state.camPos[1].toFixed(1)}, ${state.camPos[2].toFixed(1)} | ` +
                         `Look: yaw ${(state.yaw).toFixed(2)} pitch ${(state.pitch).toFixed(2)} | ` +
                         `Mobile: ${state.mobile ? 'yes' : 'no'} ${state.paused?'(paused)':''}`;

  requestAnimationFrame(render);
}
let lastTime=0;
requestAnimationFrame(render);
/* Validation: if you see green hills, stone boxes, houses, and moving guards, we passed. If screen is black, check shader compile errors in console. */
</script>
</body>
</html>